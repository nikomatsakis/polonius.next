// #![feature(nll)]
//
// struct Thing;
//
// impl Thing {
//     fn maybe_next(&mut self) -> Option<&mut Self> { None }
// }
//
// fn main() {
//     let mut temp = &mut Thing;
//
//    loop {
//        match temp.maybe_next() {
//            Some(v) => { temp = v; }
//            None => { }
//        }
//    }
// }

// temp: &'temp mut Thing
// t0: &'t0 mut Thing
// v: &'v mut Thing

a: "temp = &'L_Thing mut Thing" {
    // temp is written: clear its origins, invalidate leases based on it
    clear_origin('temp)
    invalidate_lease('L_*temp)

    // synthesize a write to `Thing`
    invalidate_lease('L_Thing)

    // introduce the lease from the mut borrow
    introduce_lease('L_Thing, 'temp)
    goto b
}

b: "t0 = &'L_*temp mut *temp" {
    // Mut borrow of `*temp` is considered a write to `*temp`
    access_origin('temp)

    // Writing to `*temp` invalidates any borrows of `*temp`
    invalidate_lease('L_*temp)

    // Overwriting `t0`
    clear_origin('t0)

    // Introduce the lease of `*temp`:
    introduce_lease('L_*temp, 't0)

    // Because we are borrowing from `*temp` and `temp: &'temp mut Thing`:
    introduce_subset('temp, 't0)

    goto c
}

c: "v = MaybeNext(t0)" {
    // Read `t0`
    access_origin('t0)

    // Overwriting `v`
    clear_origin('v)

    // MaybeNext has sig `fn(&mut Thing) -> &mut Thing` (ignore the option for now)
    introduce_subset('t0, 'v)

    goto d e
}

d: "temp = v" {
    // Incoming value of `v` is being read
    access_origin('v)

    // Because `temp` is being overwritten
    clear_origin('temp)

    // Anything that borrowed from `*temp`
    // no longer is, since `temp` is something else
    clear_lease('L_*temp)

    // Data from `'v` is flowing into `'temp`
    introduce_subset('v, 'temp)

    goto f
}

e: "(pass)" {
    goto f
}

f: "(pass)" {
    goto b
}