.type Origin <: symbol
.type Node <: symbol
.type Lease <: symbol

/////////////////////////////////////////////
// Inputs
//
// ## Assumptions about ordering
// 
// For a given node `N`...
// 
// * First we perform any accesses `access_origin(O, N)`
// * Then we invalidate any leases `invalidate_lease(L, N)`
// * Then we clear any origins or leases `clear_origin`, `clear_lease`
// * Then we introduce any subsets or leases `introduce_subset`, `introduce_lease`
// 
// This corresponds to 
// 
// ```
// place = expr
// ```
// 
// * Evaluating the expr accesses the origins (including potentially some in place)
// * Then place is overwritten, invalidating and clearing loans
// * Storing the value also creates subtyping relationships between the type of the value that was stored and the place it was stored into
//
// ## Rules to generate inputs:
//
// * For each place `P` that is accessed by the expression, generate `access_origin`...
//     * for each origin in the type of `P`
//     * for the origin of each reference that is deref'd in `P`
//          * e.g., `read((*x).0)` where `x: &'x0 (&'x1 u32, &'x2 u32)` would generate
//              * `access_origin('x0)` because of the `*`
//              * `access_origin('x1)` because the final type of `(*x).0` is `&'x1 u32`
//     * leasing a place counts as an access
// * Generate `invalidate_lease` for each loan origin that is invalidated by reads/writes
//     * e.g., if the expression reads `x`, and there is a mut borrow `'L_mut_x` of `x`, then we would generate
//       `invalidate_lease('L_mut_x)`
// * Generate `clear_origin` for each loan origin that is cleared by reads/writes
//     * e.g., if there is a lease `'L_*temp` where `temp: &T` and this expression writes to `temp`, then `'L_*temp` is cleared,
//       not invalidated. This is because memory at `*temp` is not owned, so it is not freed by writing to `temp`,
//       but `*temp` no longer names the same memory anymore.
// * Generate `clear_lease` for each lease of `*P` (or some suffix) when a mut reference at place `P` is overwritten 
//     * e.g., invalidate lease `'L_*temp` when `temp = ...` (assuming `temp: &mut T`), as the
//     `*temp` that was leased is no longer accessible under that name
// * For every `&'L_P P` expression assigned to a place of type `&'O T`:
//     * Generate `introduce_lease('L_P, 'O)`
//     * Require `typeof(P) <: T`
//     * Generate appropriate accesses/invalidations for a read from P (as stated above as well)
//     * In addition, "unroll" P to add subset relations:
//          * If `P = *Q` where `Q: &'Q T`, then `'Q: 'O` (do not continue unrolling)
//          * If `P = *Q` where `Q: &'Q mut T`, then `'Q: 'O` and continue "unrolling" `Q`
//          * Why do we continue only with `&mut`? The path we took to reach a `&` not important; the ref could just
//            be copied out anyway. For `&mut` that path *is* important, because once we finish with our loan,
//            it can be used to perform mutation again. We need to ensure that we remember the path we came from.
// * If this is a `&'L_mut_P mut P` assigned to a place of type `&'O T`:
//     * Generate `introduce_lease('L_P, 'O)`
//     * Generate appropriate accesses/invalidations for a write to P (as stated above as well)
//     * Require `typeof(P) = T`
//     * In addition, "unroll" P to add subset relations:
//          * If `P = *Q` where `Q: &'Q T`, then error (mut borrow of shared content)
//          * If `P = *Q` where `Q: &'Q mut T`, then `'Q: 'O` and continue "unrolling" `Q`
// * Generate `introduce_subset` for subsets that arise from other where-clauses or type relations on this node

// Indicates that a reference with origin `o` was dereferenced (or may be).
//
// Issued for all origins in the type of some place `P` when `P` is read.
.decl access_origin(o: Origin, n: Node)
.input access_origin

// Invalidates data potentially derived from the lease `l` at the node `n`.
//
// Issued when the place that `l` is leased from is accessed in some incompatible
// way (e.g., if `l` is an `&mut` lease of some place `P`, then `l` is invalidated
// when `P` is accessed; if `l` is a `&` lease of `P`, then it is invalidated
// when `P` is written).
.decl invalidate_lease(l: Lease, n: Node)
.input invalidate_lease

// All values with origin `o` in their type are overwritten at node `n`.
//
// Since the compiler uses unique origins in the type of all values,
// this is used for all origins in the type of `place` when you
// have an assignment like `place = ...`. 
.decl clear_origin(o: Origin, n: Node)
.input clear_origin

// The path that lease `l` referred to now refers to different memory.
//
// This is issued for a lease to `*x` when `x` is overwritten.
.decl clear_lease(l: Lease, n: Node)
.input clear_lease

// Require that `o1: o2` at node `n`.
//
// This fact indicates that a given node requires a subset relation to hold. 
// Most notably, `&'a T <: &'b T` introduces a requirement that `'a: 'b`
// (`'a <= 'b`).
.decl introduce_subset(o1: Origin, o2: Origin, n: Node)
.input introduce_subset

// Require that `l \in o` at node `n`.
//
// This is introduced for a lease expression `&place` or `&mut place`.
// The lease `l` corresponds to this particular lease expression.
// The origin `o` comes from the type that is produced (or assigned to).
.decl introduce_lease(l: Lease, o: Origin, n: Node)
.input introduce_lease

// Potential control-flow graph edge `n1 -> n2`.
.decl cfg_edge(n1: Node, n2: Node)
.input cfg_edge

/////////////////////////////////////////////
.decl origin_live_on_entry(o: Origin, n: Node)
.output origin_live_on_entry

// Note that accesses come before clears, so we check on the outgoing edges.
origin_live_on_entry(O, N) :- 
  access_origin(O, N).

origin_live_on_entry(O, N1) :- 
  cfg_edge(N1, N2),
  !clear_origin(O, N1),
  origin_live_on_entry(O, N2).

/////////////////////////////////////////////
.decl member_on_exit(l: Lease, o: Origin, n: Node)
.output member_on_exit

member_on_exit(L, O, N) :-
  introduce_lease(L, O, N).

member_on_exit(L, O, N) :-
  member_on_entry(L, O, N),
  !clear_origin(O, N),
  !clear_lease(L, N).

member_on_exit(L, O2, N) :-
  member_on_exit(L, O1, N),
  subset_on_exit(O1, O2, N).

/////////////////////////////////////////////
.decl member_on_entry(l: Lease, o: Origin, n: Node)
.output member_on_entry

member_on_entry(L, O, N) :-
  cfg_edge(Npred, N),
  member_on_exit(L, O, Npred),
  origin_live_on_entry(O, N).

/////////////////////////////////////////////
.decl subset_on_exit(o1: Origin, o2: Origin, n: Node)
.output subset_on_exit

subset_on_exit(O1, O2, N) :- // Filter out clears
  subset_on_entry(O1, O2, N),
  !clear_origin(O1, N),
  !clear_origin(O2, N).

subset_on_exit(O1, O2, N) :- // New subsets
  introduce_subset(O1, O2, N).

subset_on_exit(O1, O3, N1) :- // Transitive closure
  subset_on_exit(O1, O2, N1),
  subset_on_exit(O2, O3, N1).

/////////////////////////////////////////////
.decl subset_on_entry(o1: Origin, o2: Origin, n: Node)
.output subset_on_entry

// Carried over from predecessor.
// Subsets are filtered from the `subset_on_exit` transitive closure.
subset_on_entry(O1, O2, N2) :- 
  cfg_edge(N1, N2),
  origin_live_on_entry(O1, N2),
  origin_live_on_entry(O2, N2),
  subset_on_exit(O1, O2, N1).

////////////////////////////////////////////
.decl origin_invalidated_on_exit(o: Origin, n: Node)
.output origin_invalidated_on_exit

origin_invalidated_on_exit(O, N) :-
  invalidate_lease(L, N),
  member_on_entry(L, O, N).

origin_invalidated_on_exit(O, N) :-
  origin_invalidated_on_entry(O, N),
  !clear_origin(O, N).

////////////////////////////////////////////
.decl origin_invalidated_on_entry(o: Origin, n: Node)
.output origin_invalidated_on_entry

origin_invalidated_on_entry(O, N) :-
  cfg_edge(Npred, N),
  origin_invalidated_on_exit(O, Npred).

/////////////////////////////////////////////////////
.decl invalidated_origin_accessed(o: Origin, n: Node)
.output invalidated_origin_accessed

invalidated_origin_accessed(O, N) :-
  access_origin(O, N),
  origin_invalidated_on_entry(O, N).

